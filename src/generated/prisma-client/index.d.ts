// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  mainDish: (where?: MainDishWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  protein: (where?: ProteinWhereInput) => Promise<boolean>;
  sideDish: (where?: SideDishWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  mainDish: (where: MainDishWhereUniqueInput) => MainDishNullablePromise;
  mainDishes: (args?: {
    where?: MainDishWhereInput;
    orderBy?: MainDishOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<MainDish>;
  mainDishesConnection: (args?: {
    where?: MainDishWhereInput;
    orderBy?: MainDishOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => MainDishConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  protein: (where: ProteinWhereUniqueInput) => ProteinNullablePromise;
  proteins: (args?: {
    where?: ProteinWhereInput;
    orderBy?: ProteinOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Protein>;
  proteinsConnection: (args?: {
    where?: ProteinWhereInput;
    orderBy?: ProteinOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProteinConnectionPromise;
  sideDish: (where: SideDishWhereUniqueInput) => SideDishNullablePromise;
  sideDishes: (args?: {
    where?: SideDishWhereInput;
    orderBy?: SideDishOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<SideDish>;
  sideDishesConnection: (args?: {
    where?: SideDishWhereInput;
    orderBy?: SideDishOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => SideDishConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createMainDish: (data: MainDishCreateInput) => MainDishPromise;
  updateMainDish: (args: {
    data: MainDishUpdateInput;
    where: MainDishWhereUniqueInput;
  }) => MainDishPromise;
  updateManyMainDishes: (args: {
    data: MainDishUpdateManyMutationInput;
    where?: MainDishWhereInput;
  }) => BatchPayloadPromise;
  upsertMainDish: (args: {
    where: MainDishWhereUniqueInput;
    create: MainDishCreateInput;
    update: MainDishUpdateInput;
  }) => MainDishPromise;
  deleteMainDish: (where: MainDishWhereUniqueInput) => MainDishPromise;
  deleteManyMainDishes: (where?: MainDishWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createProtein: (data: ProteinCreateInput) => ProteinPromise;
  updateProtein: (args: {
    data: ProteinUpdateInput;
    where: ProteinWhereUniqueInput;
  }) => ProteinPromise;
  updateManyProteins: (args: {
    data: ProteinUpdateManyMutationInput;
    where?: ProteinWhereInput;
  }) => BatchPayloadPromise;
  upsertProtein: (args: {
    where: ProteinWhereUniqueInput;
    create: ProteinCreateInput;
    update: ProteinUpdateInput;
  }) => ProteinPromise;
  deleteProtein: (where: ProteinWhereUniqueInput) => ProteinPromise;
  deleteManyProteins: (where?: ProteinWhereInput) => BatchPayloadPromise;
  createSideDish: (data: SideDishCreateInput) => SideDishPromise;
  updateSideDish: (args: {
    data: SideDishUpdateInput;
    where: SideDishWhereUniqueInput;
  }) => SideDishPromise;
  updateManySideDishes: (args: {
    data: SideDishUpdateManyMutationInput;
    where?: SideDishWhereInput;
  }) => BatchPayloadPromise;
  upsertSideDish: (args: {
    where: SideDishWhereUniqueInput;
    create: SideDishCreateInput;
    update: SideDishUpdateInput;
  }) => SideDishPromise;
  deleteSideDish: (where: SideDishWhereUniqueInput) => SideDishPromise;
  deleteManySideDishes: (where?: SideDishWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  mainDish: (
    where?: MainDishSubscriptionWhereInput
  ) => MainDishSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  protein: (
    where?: ProteinSubscriptionWhereInput
  ) => ProteinSubscriptionPayloadSubscription;
  sideDish: (
    where?: SideDishSubscriptionWhereInput
  ) => SideDishSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type MainType = "STEW" | "SOUP" | "HOTSAUCE";

export type Role = "ADMIN" | "NORMAL_USER";

export type SideType = "DUMPLING" | "RICE";

export type ProteinType = "MEAT" | "FISH" | "MISCELLANEOUS";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "createdFor_ASC"
  | "createdFor_DESC";

export type MainDishOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC";

export type ProteinOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC";

export type SideDishOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "type_ASC"
  | "type_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "firstName_ASC"
  | "firstName_DESC"
  | "otherNames_ASC"
  | "otherNames_DESC"
  | "lastName_ASC"
  | "lastName_DESC"
  | "email_ASC"
  | "email_DESC"
  | "role_ASC"
  | "role_DESC"
  | "password_ASC"
  | "password_DESC"
  | "hasChangedPassword_ASC"
  | "hasChangedPassword_DESC"
  | "activated_ASC"
  | "activated_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type MainDishWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface OrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  createdFor?: Maybe<DateTimeInput>;
  createdFor_not?: Maybe<DateTimeInput>;
  createdFor_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdFor_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdFor_lt?: Maybe<DateTimeInput>;
  createdFor_lte?: Maybe<DateTimeInput>;
  createdFor_gt?: Maybe<DateTimeInput>;
  createdFor_gte?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserWhereInput>;
  main?: Maybe<MainDishWhereInput>;
  side?: Maybe<SideDishWhereInput>;
  protein?: Maybe<ProteinWhereInput>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  OR?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  NOT?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  firstName?: Maybe<String>;
  firstName_not?: Maybe<String>;
  firstName_in?: Maybe<String[] | String>;
  firstName_not_in?: Maybe<String[] | String>;
  firstName_lt?: Maybe<String>;
  firstName_lte?: Maybe<String>;
  firstName_gt?: Maybe<String>;
  firstName_gte?: Maybe<String>;
  firstName_contains?: Maybe<String>;
  firstName_not_contains?: Maybe<String>;
  firstName_starts_with?: Maybe<String>;
  firstName_not_starts_with?: Maybe<String>;
  firstName_ends_with?: Maybe<String>;
  firstName_not_ends_with?: Maybe<String>;
  otherNames?: Maybe<String>;
  otherNames_not?: Maybe<String>;
  otherNames_in?: Maybe<String[] | String>;
  otherNames_not_in?: Maybe<String[] | String>;
  otherNames_lt?: Maybe<String>;
  otherNames_lte?: Maybe<String>;
  otherNames_gt?: Maybe<String>;
  otherNames_gte?: Maybe<String>;
  otherNames_contains?: Maybe<String>;
  otherNames_not_contains?: Maybe<String>;
  otherNames_starts_with?: Maybe<String>;
  otherNames_not_starts_with?: Maybe<String>;
  otherNames_ends_with?: Maybe<String>;
  otherNames_not_ends_with?: Maybe<String>;
  lastName?: Maybe<String>;
  lastName_not?: Maybe<String>;
  lastName_in?: Maybe<String[] | String>;
  lastName_not_in?: Maybe<String[] | String>;
  lastName_lt?: Maybe<String>;
  lastName_lte?: Maybe<String>;
  lastName_gt?: Maybe<String>;
  lastName_gte?: Maybe<String>;
  lastName_contains?: Maybe<String>;
  lastName_not_contains?: Maybe<String>;
  lastName_starts_with?: Maybe<String>;
  lastName_not_starts_with?: Maybe<String>;
  lastName_ends_with?: Maybe<String>;
  lastName_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  role?: Maybe<Role>;
  role_not?: Maybe<Role>;
  role_in?: Maybe<Role[] | Role>;
  role_not_in?: Maybe<Role[] | Role>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  hasChangedPassword?: Maybe<Boolean>;
  hasChangedPassword_not?: Maybe<Boolean>;
  activated?: Maybe<Boolean>;
  activated_not?: Maybe<Boolean>;
  orders_every?: Maybe<OrderWhereInput>;
  orders_some?: Maybe<OrderWhereInput>;
  orders_none?: Maybe<OrderWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface MainDishWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<MainType>;
  type_not?: Maybe<MainType>;
  type_in?: Maybe<MainType[] | MainType>;
  type_not_in?: Maybe<MainType[] | MainType>;
  orders_every?: Maybe<OrderWhereInput>;
  orders_some?: Maybe<OrderWhereInput>;
  orders_none?: Maybe<OrderWhereInput>;
  AND?: Maybe<MainDishWhereInput[] | MainDishWhereInput>;
  OR?: Maybe<MainDishWhereInput[] | MainDishWhereInput>;
  NOT?: Maybe<MainDishWhereInput[] | MainDishWhereInput>;
}

export interface SideDishWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<SideType>;
  type_not?: Maybe<SideType>;
  type_in?: Maybe<SideType[] | SideType>;
  type_not_in?: Maybe<SideType[] | SideType>;
  orders_every?: Maybe<OrderWhereInput>;
  orders_some?: Maybe<OrderWhereInput>;
  orders_none?: Maybe<OrderWhereInput>;
  AND?: Maybe<SideDishWhereInput[] | SideDishWhereInput>;
  OR?: Maybe<SideDishWhereInput[] | SideDishWhereInput>;
  NOT?: Maybe<SideDishWhereInput[] | SideDishWhereInput>;
}

export interface ProteinWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  type?: Maybe<ProteinType>;
  type_not?: Maybe<ProteinType>;
  type_in?: Maybe<ProteinType[] | ProteinType>;
  type_not_in?: Maybe<ProteinType[] | ProteinType>;
  orders_every?: Maybe<OrderWhereInput>;
  orders_some?: Maybe<OrderWhereInput>;
  orders_none?: Maybe<OrderWhereInput>;
  AND?: Maybe<ProteinWhereInput[] | ProteinWhereInput>;
  OR?: Maybe<ProteinWhereInput[] | ProteinWhereInput>;
  NOT?: Maybe<ProteinWhereInput[] | ProteinWhereInput>;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type ProteinWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type SideDishWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface MainDishCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  type: MainType;
  orders?: Maybe<OrderCreateManyWithoutMainInput>;
}

export interface OrderCreateManyWithoutMainInput {
  create?: Maybe<OrderCreateWithoutMainInput[] | OrderCreateWithoutMainInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
}

export interface OrderCreateWithoutMainInput {
  id?: Maybe<ID_Input>;
  createdFor: DateTimeInput;
  createdBy: UserCreateOneWithoutOrdersInput;
  side: SideDishCreateOneWithoutOrdersInput;
  protein?: Maybe<ProteinCreateOneWithoutOrdersInput>;
}

export interface UserCreateOneWithoutOrdersInput {
  create?: Maybe<UserCreateWithoutOrdersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserCreateWithoutOrdersInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  otherNames?: Maybe<String>;
  lastName: String;
  email: String;
  role: Role;
  password: String;
  hasChangedPassword: Boolean;
  activated: Boolean;
}

export interface SideDishCreateOneWithoutOrdersInput {
  create?: Maybe<SideDishCreateWithoutOrdersInput>;
  connect?: Maybe<SideDishWhereUniqueInput>;
}

export interface SideDishCreateWithoutOrdersInput {
  id?: Maybe<ID_Input>;
  name: String;
  type: SideType;
}

export interface ProteinCreateOneWithoutOrdersInput {
  create?: Maybe<ProteinCreateWithoutOrdersInput>;
  connect?: Maybe<ProteinWhereUniqueInput>;
}

export interface ProteinCreateWithoutOrdersInput {
  id?: Maybe<ID_Input>;
  name: String;
  type: ProteinType;
}

export interface MainDishUpdateInput {
  name?: Maybe<String>;
  type?: Maybe<MainType>;
  orders?: Maybe<OrderUpdateManyWithoutMainInput>;
}

export interface OrderUpdateManyWithoutMainInput {
  create?: Maybe<OrderCreateWithoutMainInput[] | OrderCreateWithoutMainInput>;
  delete?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  set?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  disconnect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  update?: Maybe<
    | OrderUpdateWithWhereUniqueWithoutMainInput[]
    | OrderUpdateWithWhereUniqueWithoutMainInput
  >;
  upsert?: Maybe<
    | OrderUpsertWithWhereUniqueWithoutMainInput[]
    | OrderUpsertWithWhereUniqueWithoutMainInput
  >;
  deleteMany?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  updateMany?: Maybe<
    OrderUpdateManyWithWhereNestedInput[] | OrderUpdateManyWithWhereNestedInput
  >;
}

export interface OrderUpdateWithWhereUniqueWithoutMainInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutMainDataInput;
}

export interface OrderUpdateWithoutMainDataInput {
  createdFor?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutOrdersInput>;
  side?: Maybe<SideDishUpdateOneRequiredWithoutOrdersInput>;
  protein?: Maybe<ProteinUpdateOneWithoutOrdersInput>;
}

export interface UserUpdateOneRequiredWithoutOrdersInput {
  create?: Maybe<UserCreateWithoutOrdersInput>;
  update?: Maybe<UserUpdateWithoutOrdersDataInput>;
  upsert?: Maybe<UserUpsertWithoutOrdersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateWithoutOrdersDataInput {
  firstName?: Maybe<String>;
  otherNames?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  hasChangedPassword?: Maybe<Boolean>;
  activated?: Maybe<Boolean>;
}

export interface UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput;
  create: UserCreateWithoutOrdersInput;
}

export interface SideDishUpdateOneRequiredWithoutOrdersInput {
  create?: Maybe<SideDishCreateWithoutOrdersInput>;
  update?: Maybe<SideDishUpdateWithoutOrdersDataInput>;
  upsert?: Maybe<SideDishUpsertWithoutOrdersInput>;
  connect?: Maybe<SideDishWhereUniqueInput>;
}

export interface SideDishUpdateWithoutOrdersDataInput {
  name?: Maybe<String>;
  type?: Maybe<SideType>;
}

export interface SideDishUpsertWithoutOrdersInput {
  update: SideDishUpdateWithoutOrdersDataInput;
  create: SideDishCreateWithoutOrdersInput;
}

export interface ProteinUpdateOneWithoutOrdersInput {
  create?: Maybe<ProteinCreateWithoutOrdersInput>;
  update?: Maybe<ProteinUpdateWithoutOrdersDataInput>;
  upsert?: Maybe<ProteinUpsertWithoutOrdersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProteinWhereUniqueInput>;
}

export interface ProteinUpdateWithoutOrdersDataInput {
  name?: Maybe<String>;
  type?: Maybe<ProteinType>;
}

export interface ProteinUpsertWithoutOrdersInput {
  update: ProteinUpdateWithoutOrdersDataInput;
  create: ProteinCreateWithoutOrdersInput;
}

export interface OrderUpsertWithWhereUniqueWithoutMainInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutMainDataInput;
  create: OrderCreateWithoutMainInput;
}

export interface OrderScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  createdFor?: Maybe<DateTimeInput>;
  createdFor_not?: Maybe<DateTimeInput>;
  createdFor_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdFor_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdFor_lt?: Maybe<DateTimeInput>;
  createdFor_lte?: Maybe<DateTimeInput>;
  createdFor_gt?: Maybe<DateTimeInput>;
  createdFor_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  OR?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  NOT?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
}

export interface OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput;
  data: OrderUpdateManyDataInput;
}

export interface OrderUpdateManyDataInput {
  createdFor?: Maybe<DateTimeInput>;
}

export interface MainDishUpdateManyMutationInput {
  name?: Maybe<String>;
  type?: Maybe<MainType>;
}

export interface OrderCreateInput {
  id?: Maybe<ID_Input>;
  createdFor: DateTimeInput;
  createdBy: UserCreateOneWithoutOrdersInput;
  main: MainDishCreateOneWithoutOrdersInput;
  side: SideDishCreateOneWithoutOrdersInput;
  protein?: Maybe<ProteinCreateOneWithoutOrdersInput>;
}

export interface MainDishCreateOneWithoutOrdersInput {
  create?: Maybe<MainDishCreateWithoutOrdersInput>;
  connect?: Maybe<MainDishWhereUniqueInput>;
}

export interface MainDishCreateWithoutOrdersInput {
  id?: Maybe<ID_Input>;
  name: String;
  type: MainType;
}

export interface OrderUpdateInput {
  createdFor?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutOrdersInput>;
  main?: Maybe<MainDishUpdateOneRequiredWithoutOrdersInput>;
  side?: Maybe<SideDishUpdateOneRequiredWithoutOrdersInput>;
  protein?: Maybe<ProteinUpdateOneWithoutOrdersInput>;
}

export interface MainDishUpdateOneRequiredWithoutOrdersInput {
  create?: Maybe<MainDishCreateWithoutOrdersInput>;
  update?: Maybe<MainDishUpdateWithoutOrdersDataInput>;
  upsert?: Maybe<MainDishUpsertWithoutOrdersInput>;
  connect?: Maybe<MainDishWhereUniqueInput>;
}

export interface MainDishUpdateWithoutOrdersDataInput {
  name?: Maybe<String>;
  type?: Maybe<MainType>;
}

export interface MainDishUpsertWithoutOrdersInput {
  update: MainDishUpdateWithoutOrdersDataInput;
  create: MainDishCreateWithoutOrdersInput;
}

export interface OrderUpdateManyMutationInput {
  createdFor?: Maybe<DateTimeInput>;
}

export interface ProteinCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  type: ProteinType;
  orders?: Maybe<OrderCreateManyWithoutProteinInput>;
}

export interface OrderCreateManyWithoutProteinInput {
  create?: Maybe<
    OrderCreateWithoutProteinInput[] | OrderCreateWithoutProteinInput
  >;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
}

export interface OrderCreateWithoutProteinInput {
  id?: Maybe<ID_Input>;
  createdFor: DateTimeInput;
  createdBy: UserCreateOneWithoutOrdersInput;
  main: MainDishCreateOneWithoutOrdersInput;
  side: SideDishCreateOneWithoutOrdersInput;
}

export interface ProteinUpdateInput {
  name?: Maybe<String>;
  type?: Maybe<ProteinType>;
  orders?: Maybe<OrderUpdateManyWithoutProteinInput>;
}

export interface OrderUpdateManyWithoutProteinInput {
  create?: Maybe<
    OrderCreateWithoutProteinInput[] | OrderCreateWithoutProteinInput
  >;
  delete?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  set?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  disconnect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  update?: Maybe<
    | OrderUpdateWithWhereUniqueWithoutProteinInput[]
    | OrderUpdateWithWhereUniqueWithoutProteinInput
  >;
  upsert?: Maybe<
    | OrderUpsertWithWhereUniqueWithoutProteinInput[]
    | OrderUpsertWithWhereUniqueWithoutProteinInput
  >;
  deleteMany?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  updateMany?: Maybe<
    OrderUpdateManyWithWhereNestedInput[] | OrderUpdateManyWithWhereNestedInput
  >;
}

export interface OrderUpdateWithWhereUniqueWithoutProteinInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutProteinDataInput;
}

export interface OrderUpdateWithoutProteinDataInput {
  createdFor?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutOrdersInput>;
  main?: Maybe<MainDishUpdateOneRequiredWithoutOrdersInput>;
  side?: Maybe<SideDishUpdateOneRequiredWithoutOrdersInput>;
}

export interface OrderUpsertWithWhereUniqueWithoutProteinInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutProteinDataInput;
  create: OrderCreateWithoutProteinInput;
}

export interface ProteinUpdateManyMutationInput {
  name?: Maybe<String>;
  type?: Maybe<ProteinType>;
}

export interface SideDishCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  type: SideType;
  orders?: Maybe<OrderCreateManyWithoutSideInput>;
}

export interface OrderCreateManyWithoutSideInput {
  create?: Maybe<OrderCreateWithoutSideInput[] | OrderCreateWithoutSideInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
}

export interface OrderCreateWithoutSideInput {
  id?: Maybe<ID_Input>;
  createdFor: DateTimeInput;
  createdBy: UserCreateOneWithoutOrdersInput;
  main: MainDishCreateOneWithoutOrdersInput;
  protein?: Maybe<ProteinCreateOneWithoutOrdersInput>;
}

export interface SideDishUpdateInput {
  name?: Maybe<String>;
  type?: Maybe<SideType>;
  orders?: Maybe<OrderUpdateManyWithoutSideInput>;
}

export interface OrderUpdateManyWithoutSideInput {
  create?: Maybe<OrderCreateWithoutSideInput[] | OrderCreateWithoutSideInput>;
  delete?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  set?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  disconnect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  update?: Maybe<
    | OrderUpdateWithWhereUniqueWithoutSideInput[]
    | OrderUpdateWithWhereUniqueWithoutSideInput
  >;
  upsert?: Maybe<
    | OrderUpsertWithWhereUniqueWithoutSideInput[]
    | OrderUpsertWithWhereUniqueWithoutSideInput
  >;
  deleteMany?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  updateMany?: Maybe<
    OrderUpdateManyWithWhereNestedInput[] | OrderUpdateManyWithWhereNestedInput
  >;
}

export interface OrderUpdateWithWhereUniqueWithoutSideInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutSideDataInput;
}

export interface OrderUpdateWithoutSideDataInput {
  createdFor?: Maybe<DateTimeInput>;
  createdBy?: Maybe<UserUpdateOneRequiredWithoutOrdersInput>;
  main?: Maybe<MainDishUpdateOneRequiredWithoutOrdersInput>;
  protein?: Maybe<ProteinUpdateOneWithoutOrdersInput>;
}

export interface OrderUpsertWithWhereUniqueWithoutSideInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutSideDataInput;
  create: OrderCreateWithoutSideInput;
}

export interface SideDishUpdateManyMutationInput {
  name?: Maybe<String>;
  type?: Maybe<SideType>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  firstName: String;
  otherNames?: Maybe<String>;
  lastName: String;
  email: String;
  role: Role;
  password: String;
  hasChangedPassword: Boolean;
  activated: Boolean;
  orders?: Maybe<OrderCreateManyWithoutCreatedByInput>;
}

export interface OrderCreateManyWithoutCreatedByInput {
  create?: Maybe<
    OrderCreateWithoutCreatedByInput[] | OrderCreateWithoutCreatedByInput
  >;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
}

export interface OrderCreateWithoutCreatedByInput {
  id?: Maybe<ID_Input>;
  createdFor: DateTimeInput;
  main: MainDishCreateOneWithoutOrdersInput;
  side: SideDishCreateOneWithoutOrdersInput;
  protein?: Maybe<ProteinCreateOneWithoutOrdersInput>;
}

export interface UserUpdateInput {
  firstName?: Maybe<String>;
  otherNames?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  hasChangedPassword?: Maybe<Boolean>;
  activated?: Maybe<Boolean>;
  orders?: Maybe<OrderUpdateManyWithoutCreatedByInput>;
}

export interface OrderUpdateManyWithoutCreatedByInput {
  create?: Maybe<
    OrderCreateWithoutCreatedByInput[] | OrderCreateWithoutCreatedByInput
  >;
  delete?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  set?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  disconnect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  update?: Maybe<
    | OrderUpdateWithWhereUniqueWithoutCreatedByInput[]
    | OrderUpdateWithWhereUniqueWithoutCreatedByInput
  >;
  upsert?: Maybe<
    | OrderUpsertWithWhereUniqueWithoutCreatedByInput[]
    | OrderUpsertWithWhereUniqueWithoutCreatedByInput
  >;
  deleteMany?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  updateMany?: Maybe<
    OrderUpdateManyWithWhereNestedInput[] | OrderUpdateManyWithWhereNestedInput
  >;
}

export interface OrderUpdateWithWhereUniqueWithoutCreatedByInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutCreatedByDataInput;
}

export interface OrderUpdateWithoutCreatedByDataInput {
  createdFor?: Maybe<DateTimeInput>;
  main?: Maybe<MainDishUpdateOneRequiredWithoutOrdersInput>;
  side?: Maybe<SideDishUpdateOneRequiredWithoutOrdersInput>;
  protein?: Maybe<ProteinUpdateOneWithoutOrdersInput>;
}

export interface OrderUpsertWithWhereUniqueWithoutCreatedByInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutCreatedByDataInput;
  create: OrderCreateWithoutCreatedByInput;
}

export interface UserUpdateManyMutationInput {
  firstName?: Maybe<String>;
  otherNames?: Maybe<String>;
  lastName?: Maybe<String>;
  email?: Maybe<String>;
  role?: Maybe<Role>;
  password?: Maybe<String>;
  hasChangedPassword?: Maybe<Boolean>;
  activated?: Maybe<Boolean>;
}

export interface MainDishSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<MainDishWhereInput>;
  AND?: Maybe<
    MainDishSubscriptionWhereInput[] | MainDishSubscriptionWhereInput
  >;
  OR?: Maybe<MainDishSubscriptionWhereInput[] | MainDishSubscriptionWhereInput>;
  NOT?: Maybe<
    MainDishSubscriptionWhereInput[] | MainDishSubscriptionWhereInput
  >;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  OR?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  NOT?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface ProteinSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProteinWhereInput>;
  AND?: Maybe<ProteinSubscriptionWhereInput[] | ProteinSubscriptionWhereInput>;
  OR?: Maybe<ProteinSubscriptionWhereInput[] | ProteinSubscriptionWhereInput>;
  NOT?: Maybe<ProteinSubscriptionWhereInput[] | ProteinSubscriptionWhereInput>;
}

export interface SideDishSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<SideDishWhereInput>;
  AND?: Maybe<
    SideDishSubscriptionWhereInput[] | SideDishSubscriptionWhereInput
  >;
  OR?: Maybe<SideDishSubscriptionWhereInput[] | SideDishSubscriptionWhereInput>;
  NOT?: Maybe<
    SideDishSubscriptionWhereInput[] | SideDishSubscriptionWhereInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface MainDish {
  id: ID_Output;
  name: String;
  type: MainType;
}

export interface MainDishPromise extends Promise<MainDish>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<MainType>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MainDishSubscription
  extends Promise<AsyncIterator<MainDish>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<MainType>>;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MainDishNullablePromise
  extends Promise<MainDish | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<MainType>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Order {
  id: ID_Output;
  createdAt: DateTimeOutput;
  createdFor: DateTimeOutput;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  createdFor: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  main: <T = MainDishPromise>() => T;
  side: <T = SideDishPromise>() => T;
  protein: <T = ProteinPromise>() => T;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdFor: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdBy: <T = UserSubscription>() => T;
  main: <T = MainDishSubscription>() => T;
  side: <T = SideDishSubscription>() => T;
  protein: <T = ProteinSubscription>() => T;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  createdFor: () => Promise<DateTimeOutput>;
  createdBy: <T = UserPromise>() => T;
  main: <T = MainDishPromise>() => T;
  side: <T = SideDishPromise>() => T;
  protein: <T = ProteinPromise>() => T;
}

export interface User {
  id: ID_Output;
  firstName: String;
  otherNames?: String;
  lastName: String;
  email: String;
  role: Role;
  password: String;
  hasChangedPassword: Boolean;
  activated: Boolean;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  otherNames: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  password: () => Promise<String>;
  hasChangedPassword: () => Promise<Boolean>;
  activated: () => Promise<Boolean>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  otherNames: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  password: () => Promise<AsyncIterator<String>>;
  hasChangedPassword: () => Promise<AsyncIterator<Boolean>>;
  activated: () => Promise<AsyncIterator<Boolean>>;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  otherNames: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  password: () => Promise<String>;
  hasChangedPassword: () => Promise<Boolean>;
  activated: () => Promise<Boolean>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SideDish {
  id: ID_Output;
  name: String;
  type: SideType;
}

export interface SideDishPromise extends Promise<SideDish>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<SideType>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SideDishSubscription
  extends Promise<AsyncIterator<SideDish>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<SideType>>;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface SideDishNullablePromise
  extends Promise<SideDish | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<SideType>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Protein {
  id: ID_Output;
  name: String;
  type: ProteinType;
}

export interface ProteinPromise extends Promise<Protein>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<ProteinType>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProteinSubscription
  extends Promise<AsyncIterator<Protein>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<ProteinType>>;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProteinNullablePromise
  extends Promise<Protein | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<ProteinType>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface MainDishConnection {
  pageInfo: PageInfo;
  edges: MainDishEdge[];
}

export interface MainDishConnectionPromise
  extends Promise<MainDishConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<MainDishEdge>>() => T;
  aggregate: <T = AggregateMainDishPromise>() => T;
}

export interface MainDishConnectionSubscription
  extends Promise<AsyncIterator<MainDishConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<MainDishEdgeSubscription>>>() => T;
  aggregate: <T = AggregateMainDishSubscription>() => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface MainDishEdge {
  node: MainDish;
  cursor: String;
}

export interface MainDishEdgePromise
  extends Promise<MainDishEdge>,
    Fragmentable {
  node: <T = MainDishPromise>() => T;
  cursor: () => Promise<String>;
}

export interface MainDishEdgeSubscription
  extends Promise<AsyncIterator<MainDishEdge>>,
    Fragmentable {
  node: <T = MainDishSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateMainDish {
  count: Int;
}

export interface AggregateMainDishPromise
  extends Promise<AggregateMainDish>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateMainDishSubscription
  extends Promise<AsyncIterator<AggregateMainDish>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProteinConnection {
  pageInfo: PageInfo;
  edges: ProteinEdge[];
}

export interface ProteinConnectionPromise
  extends Promise<ProteinConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProteinEdge>>() => T;
  aggregate: <T = AggregateProteinPromise>() => T;
}

export interface ProteinConnectionSubscription
  extends Promise<AsyncIterator<ProteinConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProteinEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProteinSubscription>() => T;
}

export interface ProteinEdge {
  node: Protein;
  cursor: String;
}

export interface ProteinEdgePromise extends Promise<ProteinEdge>, Fragmentable {
  node: <T = ProteinPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProteinEdgeSubscription
  extends Promise<AsyncIterator<ProteinEdge>>,
    Fragmentable {
  node: <T = ProteinSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProtein {
  count: Int;
}

export interface AggregateProteinPromise
  extends Promise<AggregateProtein>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProteinSubscription
  extends Promise<AsyncIterator<AggregateProtein>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface SideDishConnection {
  pageInfo: PageInfo;
  edges: SideDishEdge[];
}

export interface SideDishConnectionPromise
  extends Promise<SideDishConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<SideDishEdge>>() => T;
  aggregate: <T = AggregateSideDishPromise>() => T;
}

export interface SideDishConnectionSubscription
  extends Promise<AsyncIterator<SideDishConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<SideDishEdgeSubscription>>>() => T;
  aggregate: <T = AggregateSideDishSubscription>() => T;
}

export interface SideDishEdge {
  node: SideDish;
  cursor: String;
}

export interface SideDishEdgePromise
  extends Promise<SideDishEdge>,
    Fragmentable {
  node: <T = SideDishPromise>() => T;
  cursor: () => Promise<String>;
}

export interface SideDishEdgeSubscription
  extends Promise<AsyncIterator<SideDishEdge>>,
    Fragmentable {
  node: <T = SideDishSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateSideDish {
  count: Int;
}

export interface AggregateSideDishPromise
  extends Promise<AggregateSideDish>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateSideDishSubscription
  extends Promise<AsyncIterator<AggregateSideDish>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface MainDishSubscriptionPayload {
  mutation: MutationType;
  node: MainDish;
  updatedFields: String[];
  previousValues: MainDishPreviousValues;
}

export interface MainDishSubscriptionPayloadPromise
  extends Promise<MainDishSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = MainDishPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = MainDishPreviousValuesPromise>() => T;
}

export interface MainDishSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<MainDishSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = MainDishSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = MainDishPreviousValuesSubscription>() => T;
}

export interface MainDishPreviousValues {
  id: ID_Output;
  name: String;
  type: MainType;
}

export interface MainDishPreviousValuesPromise
  extends Promise<MainDishPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<MainType>;
}

export interface MainDishPreviousValuesSubscription
  extends Promise<AsyncIterator<MainDishPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<MainType>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface OrderPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  createdFor: DateTimeOutput;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  createdFor: () => Promise<DateTimeOutput>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  createdFor: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProteinSubscriptionPayload {
  mutation: MutationType;
  node: Protein;
  updatedFields: String[];
  previousValues: ProteinPreviousValues;
}

export interface ProteinSubscriptionPayloadPromise
  extends Promise<ProteinSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProteinPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProteinPreviousValuesPromise>() => T;
}

export interface ProteinSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProteinSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProteinSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProteinPreviousValuesSubscription>() => T;
}

export interface ProteinPreviousValues {
  id: ID_Output;
  name: String;
  type: ProteinType;
}

export interface ProteinPreviousValuesPromise
  extends Promise<ProteinPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<ProteinType>;
}

export interface ProteinPreviousValuesSubscription
  extends Promise<AsyncIterator<ProteinPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<ProteinType>>;
}

export interface SideDishSubscriptionPayload {
  mutation: MutationType;
  node: SideDish;
  updatedFields: String[];
  previousValues: SideDishPreviousValues;
}

export interface SideDishSubscriptionPayloadPromise
  extends Promise<SideDishSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = SideDishPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = SideDishPreviousValuesPromise>() => T;
}

export interface SideDishSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<SideDishSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = SideDishSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = SideDishPreviousValuesSubscription>() => T;
}

export interface SideDishPreviousValues {
  id: ID_Output;
  name: String;
  type: SideType;
}

export interface SideDishPreviousValuesPromise
  extends Promise<SideDishPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  type: () => Promise<SideType>;
}

export interface SideDishPreviousValuesSubscription
  extends Promise<AsyncIterator<SideDishPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  type: () => Promise<AsyncIterator<SideType>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface UserPreviousValues {
  id: ID_Output;
  firstName: String;
  otherNames?: String;
  lastName: String;
  email: String;
  role: Role;
  password: String;
  hasChangedPassword: Boolean;
  activated: Boolean;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  firstName: () => Promise<String>;
  otherNames: () => Promise<String>;
  lastName: () => Promise<String>;
  email: () => Promise<String>;
  role: () => Promise<Role>;
  password: () => Promise<String>;
  hasChangedPassword: () => Promise<Boolean>;
  activated: () => Promise<Boolean>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  firstName: () => Promise<AsyncIterator<String>>;
  otherNames: () => Promise<AsyncIterator<String>>;
  lastName: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  role: () => Promise<AsyncIterator<Role>>;
  password: () => Promise<AsyncIterator<String>>;
  hasChangedPassword: () => Promise<AsyncIterator<Boolean>>;
  activated: () => Promise<AsyncIterator<Boolean>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

export type Long = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "MainDish",
    embedded: false
  },
  {
    name: "SideDish",
    embedded: false
  },
  {
    name: "Protein",
    embedded: false
  },
  {
    name: "Role",
    embedded: false
  },
  {
    name: "MainType",
    embedded: false
  },
  {
    name: "SideType",
    embedded: false
  },
  {
    name: "ProteinType",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
